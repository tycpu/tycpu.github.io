---
layout: post
title: "Role of the Boot ROM (BL0)"
date: 2025-05-18 12:00:00 +0900
tags: [bootrom, arm64, bootloader, secure-boot]
---

## ðŸ§± Role of the Boot ROM (BL0)

I mentioned before that if the reset pin gets into a high state and the POR exits the reset state,  
the CPU jumps to the reset vector.  
The reset vector has the starting address of BOOTROM.

---

BOOTROM is a code that is hard-coded with assembly and is read-only.  
This code is custom-made for vendors like Samsung and Qualcomm.

The reason why this code is written in assembly is because,  
at this time, there is no MMU (used for virtual addressing), no cache, and no stack.  
So the developer can't write BOOTROM code using virtual addresses or assume register initialization.

Additionally, BOOTROM is operated in a very limited space in the SoC, like SRAM.  
This is due to booting speed and security reasons.  
If this code is too heavy, booting becomes slower and the system becomes more exposed to potential attacks.

---

We have to understand why BOOTROM is needed.  
This code is not only the starting point of booting.

---

**First**, I said that this code is the starting point of booting.  
But we have to focus on the word **"starting."**  
If this point can't start, the SoC cannot operate at all.  
So this code is always mandatory and **must be executed no matter what**.

---

**Second**, if this code is hacked, the SoC also cannot be operated.  
So **security is extremely important** for BOOTROM code.  
Fortunately, this code is hard-coded, so itâ€™s very difficult to hack it.

Also, BOOTROM code **verifies the digital signature** of all bootloaders.  
BOOTROM has the **vendorâ€™s public key** embedded in advance, and it uses it to verify the authenticity of bootloaders.

---

**Third**, the CPU needs an entry point for the next bootloader, like BL1.  
BOOTROM provides this entry point to the CPU.

This is made possible with a **boot mode pin**.  
The boot mode pin is a kind of hardware, like a signal switch.  
Using this signal, BOOTROM can determine **the location of the boot source**.

Additionally, BOOTROM performs some simple initial tasks like **SRAM initialization and watchdog disable**.  
After that, other bootloaders can be executed in **a more advanced environment** like DRAM and C language.
